// Generated by CoffeeScript 1.9.2
var send;

send = require('../src/send');

module.exports = function(options) {
  var channels, check, closechanneliffinshed, interval, messages, removemessageifcomplete, startifstopped, stoptickiffinished, tick, timeout;
  if (options == null) {
    options = {};
  }
  interval = options.interval, timeout = options.timeout;
  if (interval == null) {
    interval = 5000;
  }
  if (timeout == null) {
    timeout = 5000;
  }
  channels = {};
  messages = {};
  tick = null;
  check = function() {
    var channel, completed, message, msgid, name, now, results;
    now = process.hrtime();
    console.log('RETRYING');
    results = [];
    for (msgid in messages) {
      message = messages[msgid];
      if (!(message.started < now + timeout)) {
        continue;
      }
      message.started = now;
      results.push((function() {
        var ref, results1;
        ref = message.channels;
        results1 = [];
        for (name in ref) {
          completed = ref[name];
          if (completed) {
            continue;
          }
          channel = channels[name];
          results1.push(channel.socket.send(msgid, message.data));
        }
        return results1;
      })());
    }
    return results;
  };
  startifstopped = function() {
    if (tick != null) {
      return;
    }
    return tick = setInterval(check, interval);
  };
  closechanneliffinshed = function(name, channel) {
    if (Object.keys(channel.messages).length === 0) {
      return channel.socket.close();
    }
  };
  removemessageifcomplete = function(msgid, message) {
    var completed, name, ref;
    ref = message.channels;
    for (name in ref) {
      completed = ref[name];
      if (!completed) {
        return;
      }
    }
    delete messages[msgid];
    console.log("FIN " + msgid);
    return stoptickiffinished();
  };
  stoptickiffinished = function() {
    if (Object.keys(messages).length === 0) {
      clearInterval(tick);
      return tick = null;
    }
  };
  return {
    connect: function(name, addresses) {
      return channels[name] = {
        socket: send(addresses, function(msgid) {
          var channel, message;
          channel = channels[name];
          if (channel != null) {
            delete channel.messages[msgid];
            closechanneliffinshed(name, channel);
          }
          message = messages[msgid];
          if ((message != null) && (message.channels[name] != null)) {
            message.channels[name] = true;
            return removemessageifcomplete(msgid, message);
          }
        }),
        messages: {}
      };
    },
    publish: function(msgid, data, names) {
      var i, len, name;
      if (!(names instanceof Array)) {
        names = [names];
      }
      messages[msgid] = {
        started: process.hrtime(),
        data: data,
        channels: {}
      };
      for (i = 0, len = names.length; i < len; i++) {
        name = names[i];
        messages[msgid].channels[name] = false;
        channels[name].messages[msgid] = true;
        channels[name].socket.send(msgid, data);
      }
      return startifstopped();
    },
    close: function() {
      var _, channel;
      for (_ in channels) {
        channel = channels[_];
        channel.socket.close();
      }
      channels = {};
      return messages = {};
    }
  };
};
